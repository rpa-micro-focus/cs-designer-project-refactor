########################################################################################################################
#!!
#! @input action: DOWNLOAD, UPLOAD
#!!#
########################################################################################################################
namespace: io.cloudslang.microfocus.rpa.designer.project.refactor._operations
operation:
  name: synchronize_files
  inputs:
    - action
    - ws_user
    - ws_password:
        sensitive: true
    - ws_tenant:
        required: true
    - session_folder
    - designer_url:
        private: true
        default: "${get_sp('io.cloudslang.microfocus.rpa.designer_url')}"
    - idm_url:
        private: true
        default: "${get_sp('io.cloudslang.microfocus.rpa.idm_url')}"
    - idm_user:
        private: true
        default: "${get_sp('io.cloudslang.microfocus.rpa.idm_username')}"
    - idm_password:
        private: true
        default: "${get_sp('io.cloudslang.microfocus.rpa.idm_password')}"
        sensitive: true
  python_action:
    use_jython: false
    script: "from urllib import request\r\nimport http.cookiejar\r\nimport ssl\r\nimport json\r\nimport base64\r\nimport pathlib\r\nimport os\r\nimport shutil\r\nimport filecmp\r\n\r\nssl._create_default_https_context = ssl._create_unverified_context\r\n\r\nclass Context:\r\n    def __init__(self, designer_url, idm_url, idm_user, idm_password):\r\n        self.__designer_url = designer_url\r\n        self.__idm_url = idm_url\r\n        self.__idm_user = idm_user\r\n        self.__idm_password = idm_password\r\n\r\n    @property\r\n    def designer_url(self):\r\n        return self.__designer_url\r\n\r\n    @property\r\n    def idm_url(self):\r\n        return self.__idm_url\r\n\r\n    @property\r\n    def idm_user(self):\r\n        return self.__idm_user\r\n\r\n    @property\r\n    def idm_password(self):\r\n        return self.__idm_password\r\n\r\n\r\ncj = http.cookiejar.CookieJar()\r\nopener = request.build_opener(request.HTTPCookieProcessor(cj))\r\n\r\ndef http_get(url):\r\n    req =  request.Request('%s%s' % (context.designer_url, url))      #\r\n    resp = opener.open(req)\r\n    return resp.read()\r\n\r\ndef get_ws_id():\r\n    ws_json = http_get('/rest/v0/workspaces')\r\n    return json.loads(ws_json)[0]['id']\r\n\r\ndef get_projects(ws_id):\r\n    projects_json = http_get('/rest/v0/workspaces/%s/projects' % ws_id)\r\n    return projects_json\r\n\r\ndef get_projects_files(projects_json):\r\n    projects = json.loads(projects_json)\r\n    projects_p = []\r\n\r\n    for project in projects:\r\n        folders = {}\r\n        files = {}\r\n\r\n        project_id = int(project.get('id'))\r\n        project_name = project.get('text')\r\n        children = project.get('children')\r\n\r\n        queue = []\r\n        if children is not None:\r\n            queue.append({'parent' : project_name, 'children' : children})\r\n\r\n        folders[project_name] = 'PROJECT_FOLDER'+':'+str(project_id)    # project is also a folder\r\n        while len(queue) > 0:\r\n            element = queue.pop();\r\n            parent = element.get('parent')\r\n            children = element.get('children')\r\n            for child in children:\r\n                child_name = child.get('text')\r\n                me = parent + '/' + child_name\r\n                children = child.get('children')\r\n                type = child.get('type')\r\n                id = child.get('id')\r\n                if type.endswith('FOLDER'):             #LIBRARY_FOLDER, CONFIGURATION_FOLDER, SYSTEM_PROP_ROOT_FOLDER, SYSTEM_PROP_FOLDER, FOLDER\r\n                    folders[me] = type+':'+id\r\n                else:                                   #FLOW, PYTHON_OPERATION, SEQ_OPERATION, SYSTEM_PROPERTY\r\n                    path = me+'.sl'\r\n                    files[path] = type+':'+id\r\n                if children is not None:\r\n                    queue.append({'parent' : me, 'children':children})\r\n        projects_p.append({\r\n            'project_id' : project_id,\r\n            'project_name' : project_name,\r\n            'folders' : folders,\r\n            'files' : files\r\n        })\r\n    return projects_p\r\n\r\ndef get_token(ws_user, ws_password, ws_tenant):\r\n    json_data = '{\"tenantName\":\"%s\",\"passwordCredentials\":{\"username\":\"%s\",\"password\":\"%s\"}}' % (ws_tenant, ws_user, ws_password)\r\n    credentials = (context.idm_user + ':' + context.idm_password).encode('utf-8')\r\n    base64_encoded_credentials = base64.b64encode(credentials).decode('utf-8')\r\n\r\n    req =  request.Request('%s/v3.0/tokens?generateHPSSO=true' % context.idm_url, data=json_data.encode('utf-8'), method='POST')\r\n    req.add_header('Authorization', 'Basic ' + base64_encoded_credentials)\r\n    req.add_header('Accept', 'application/json')\r\n    req.add_header('Content-Type', 'application/json;charset=UTF-8')\r\n\r\n    resp = opener.open(req)\r\n    data = resp.read()\r\n    json_data = json.loads(data)\r\n    idm_token = json_data.get('token').get('id')\r\n\r\n    req =  request.Request('%s/' % (context.designer_url))      # to obtain the CSRF token, two requests must be made\r\n    opener.open(req)\r\n\r\n    req = request.Request('%s/rest/v0/users/me' % (context.designer_url))\r\n    resp = opener.open(req)\r\n    xcsfr_token = resp.info().get_all('X-CSRF-TOKEN')[0]\r\n\r\n    return idm_token, xcsfr_token\r\n\r\n\r\n#gets file content\r\ndef get_file (ws_id, file_id):\r\n    req =  request.Request('%s/rest/v0/elements/%s?workspaceId=%s' % (context.designer_url, file_id, ws_id))\r\n    resp = opener.open(req)\r\n    json_data = json.loads(resp.read())\r\n    file_content = json_data.get('element').get('fileSource')\r\n    file_content = file_content.replace('\\r\\n', '\\n')   # is it a defect?\r\n    return file_content\r\n\r\n#creates file or folder\r\ndef create_element(csrf, name, type, folder_id, file_content):\r\n    json_data = '{ \"text\": \"%s\", \"type\": \"%s\", \"parentId\": \"%s\", \"language\": \"CloudSlang\", \"fileSource\": %s}' % (name, type, folder_id, json.dumps(file_content))\r\n    req =  request.Request('%s/rest/v0/elements' % (context.designer_url), data=json_data.encode('utf-8'), method='POST')\r\n    req.add_header('X-CSRF-TOKEN', csrf)\r\n    req.add_header('Content-Type', 'application/json')\r\n    resp = opener.open(req)\r\n    json_data = resp.read()\r\n    return json.loads(json_data).get('id')\r\n\r\n#changes content of an existing file\r\ndef upload_file(csrf, file_id, file_path):\r\n    f = open(file_path, 'r')\r\n    file_content = f.read()\r\n    f.close()\r\n\r\n    req =  request.Request('%s/rest/v0/elements/%s' % (context.designer_url, file_id), data=file_content.encode('utf-8'), method='PUT')\r\n    req.add_header('X-CSRF-TOKEN', csrf)\r\n    req.add_header('Content-Type', 'application/json')\r\n    resp = opener.open(req)\r\n\r\n#creates a new file\r\ndef create_file(csrf, folder_id, file_path):\r\n    f = open(file_path, 'r')\r\n    file_content = f.read()\r\n    f.close()\r\n    type = \\\r\n        'FLOW' if 'flow:' in file_content else \\\r\n        'SEQ_OPERATION' if 'sequential_action:' in file_content else \\\r\n        'PYTHON_OPERATION' if 'operation:' in file_content else \\\r\n        'SYSTEM_PROPERTY' if 'properties:' in file_content else \\\r\n        None\r\n    return create_element(csrf, file_path.split('/')[-1][:-3], type, folder_id, file_content)\r\n\r\n#removes file or folder\r\ndef delete_element (csrf, element_id):\r\n    req =  request.Request('%s/rest/v0/elements/%s' % (context.designer_url, element_id), method='DELETE')\r\n    req.add_header('X-CSRF-TOKEN', csrf)\r\n    resp = opener.open(req)\r\n\r\ndef logout():\r\n    req =  request.Request('%s/j_spring_security_logout' % (context.designer_url))\r\n    resp = opener.open(req)\r\n\r\n\r\n#gives a recursive list of all folders and files under the given folder\r\ndef get_files(folder):\r\n    folder_list = set()\r\n    file_list = []\r\n    prefix_len = len(folder)+1        # remove also ending /\r\n    for root, dir, files in os.walk(folder):\r\n        relative_root = root[prefix_len:].replace(os.sep, '/')\r\n        folder_list.add(relative_root)\r\n        file_list += [relative_root+'/'+x for x in files]\r\n    return folder_list, file_list\r\n\r\ndef get_diff(original_folder, workspace_folder):\r\n    original_folders, original_files = get_files(original_folder)\r\n    original_files = set(original_files)                # convert to set\r\n    workspace_folders, workspace_files = get_files(workspace_folder)\r\n\r\n    created_files = []\r\n    changed_files = []\r\n    for w_file in workspace_files:\r\n        if w_file in original_files:\r\n            original_files.remove(w_file)\r\n            if not filecmp.cmp(original_folder+os.sep+w_file, workspace_folder+os.sep+w_file, shallow=False):\r\n                changed_files.append(w_file)\r\n        else:\r\n            created_files.append(w_file)\r\n    deleted_files = list(original_files)\r\n    created_folders = workspace_folders - original_folders\r\n    deleted_folders = original_folders - workspace_folders\r\n\r\n    return created_folders, deleted_folders, created_files, changed_files, deleted_files\r\n\r\n#out of list of folders, keep only the ones with longest length (leaf nodes)\r\n#if reverse = True, it keeps the longest path (leaf nodes); if False, it keeps shortest (root nodes)\r\n#if where_list is None, it looks for folders in the same list as the files are\r\ndef optimize_list(what_list, where_list = None, reverse = False):\r\n    optimized_list = []\r\n    if where_list is None:\r\n        where_list = optimized_list\r\n    for f in sorted(what_list, reverse = reverse): # reverse = True -> leaf nodes first; reverse = False -> root nodes first\r\n        skip = False\r\n        for fo in where_list:\r\n            if reverse:\r\n                if fo.startswith(f):    # leaf node starts with root node\r\n                    skip = True\r\n                    break\r\n            else:\r\n                if f.startswith(fo):    # root node starts with leaf node\r\n                    skip = True\r\n                    break\r\n        if not skip:\r\n            optimized_list.append(f)\r\n    return optimized_list\r\n\r\n\r\ndef execute(action, ws_user, ws_password, ws_tenant, session_folder, designer_url, idm_url, idm_user, idm_password):\r\n    try:\r\n        failure = ''\r\n\r\n        global context\r\n        context = Context(designer_url, idm_url, idm_user, idm_password)\r\n        idm_token, csrf = get_token(ws_user, ws_password, ws_tenant)\r\n        ws_id = get_ws_id()\r\n        projects_json = get_projects(ws_id)\r\n        projects_files = get_projects_files(projects_json)\r\n\r\n        original_folder = os.path.join(session_folder, ws_user, \"original\")\r\n        workspace_folder = os.path.join(session_folder, ws_user, 'workspace')\r\n        for project_files in projects_files:\r\n            folders_dict = project_files['folders']\r\n            files_dict = project_files['files']\r\n            if action == 'DOWNLOAD':\r\n                folders = optimize_list(folders_dict.keys(), reverse = True) #out of list of folders, keep only the ones with longest length (leaf nodes)\r\n                for folder in folders:\r\n                    print('Creating '+folder)\r\n                    pathlib.Path(os.path.join(original_folder, folder)).mkdir(parents=True, exist_ok=True)\r\n                for file_path, file_id in files_dict.items():\r\n                    print('Downloading '+file_path)\r\n                    file_content = get_file(ws_id, file_id.split(':')[1])\r\n                    f = open(os.path.join(original_folder, file_path), 'w')\r\n                    f.write(file_content)\r\n                    f.close()\r\n                shutil.copytree(original_folder, workspace_folder)\r\n            else:\r\n                created_folders, deleted_folders, created_files, changed_files, deleted_files = get_diff(original_folder, workspace_folder)\r\n                deleted_folders = optimize_list(deleted_folders)            #   -> out of deleted folders, keep only root folders; e.g. from ['/root','/root/child'] -> ['/root']\r\n\r\n                for folder in deleted_folders:\r\n                    print('Deleting folder '+folder)\r\n                    delete_element(csrf, folders_dict.get(folder).split(':')[1])\r\n                for file in optimize_list(deleted_files, deleted_folders):  #   -> filter out deleted files that belong to any deleted folder\r\n                    print('Deleting file '+file)\r\n                    delete_element(csrf, files_dict.get(file).split(':')[1])\r\n                for folder in sorted(created_folders):                      # create folders in sorted order -> from root to leaves\r\n                    print('Creating folder '+folder)\r\n                    folder_id = create_element(csrf, folder.split('/')[-1], 'FOLDER', folders_dict.get(folder[:folder.rfind('/')]).split(':')[1], None)\r\n                    folders_dict[folder] = 'FOLDER:'+str(folder_id)\r\n                for file in changed_files:\r\n                    print('Changing file '+file)\r\n                    upload_file(csrf, files_dict.get(file).split(':')[1], os.path.join(workspace_folder, file))\r\n                for file in created_files:\r\n                    print('Creating file '+file)\r\n                    create_file(csrf, folders_dict.get(file[0:file.rfind('/')]).split(':')[1], os.path.join(workspace_folder, file))\r\n                shutil.rmtree(original_folder)\r\n                shutil.copytree(workspace_folder, original_folder)\r\n        logout()\r\n\r\n    except Exception as e:\r\n        failure = \"%s: %s\" % (type(e).__name__, str(e))\r\n    return { 'failure' : failure }"
  outputs:
    - failure
  results:
    - SUCCESS: '${len(failure) == 0}'
    - FAILURE
